# 笔记
### 
* win10快捷键
* Win+Tab 唤起时间线
* Ctrl + Tab 切换窗口
* 打开云剪贴板（Win + V）
* 锁定桌面（Win+L）
* 显示桌面（ Win+D）
* 召唤Windows截图（Win + Shift + S）
* 打开搜索（Win + S）
* 打开操作中心（Win+A）
* 打开文件管理器（Win+ E）
* 打开设置（Win + I ）
* 虚拟桌面
* Win + Ctrl + D 创建虚拟桌面
* Win + Ctrl + F4 关闭当前虚拟桌面
* Win + Ctrl + ← 向左切换虚拟桌面
* Win + Ctrl + → 向右切换虚拟桌面
### idea常用快捷键
  * 常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 
  * 例如要输入for(User user : users)只需输入user.for+Tab 
  * 再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。代码标签输入完成后，按Tab，生成代码。
  
  * Ctrl+Alt+O 优化导入的类和包 
  * Ctrl+R 替换文本
  * Ctrl+D 复制行 
  * 使用 Ctrl-Shift-V 快捷键可以将最近使用的剪贴板内容选择插入到文本。使用时系统会弹出一个含有剪贴内容的对话框，从中你可以选择你要粘贴的部分。
  * 按 Alt-Q 可以不需要移动代码就能查看当前方法地声明。连续按两次会显示当前所编辑的类名。
  * Ctrl-Shift-Backspace 让你调转到代码中所做改变的最后一个地方。 
  * 多按几次 Ctrl-Shift-Backspace 查看更深的修改历史。
  * Ctrl＋Shift＋Insert可以选择剪贴板内容并插入
  * Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 
  * Ctrl+W 选中代码，连续按会有其他效果 
  * Ctrl+Shift+上下键  上下移动代码 
  
  * Ctrl+Alt+T  生成try catch  或者 Alt+enter 
  * CTRL+ALT+L  格式化代码  
  
  * Ctrl+Alt+鼠标左键查看和进入接口实现类
  * CTRL+SHIFT+SPACE 自动补全代码  
  * Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/*...*/ ） 
  * Alt+Insert 生成代码(如get,set方法,构造函数等)   或者右键（Generate） Alt + Insert 组合 生成get和set方法
  * Shift+F6，重命名 
  * Ctrl+ Alt + Home 在视图与控制器之间跳转或者Ctrl + 鼠标左键直接点进去
  
  * Win+Shift+S 和 Ctrl+Shift+A 截取活动窗口；
  
### 插件
  * Background Image Plus
  * 把单调的背景换成自己喜欢的图片即可。安装之后，在打开View选项，就可以看到Set Background Image选项了。
  
  * findBugs
  * 找到那些被你隐藏的bug
  
  * Free Mybatis plugin
  * 点击箭头我们就可以直接定位到xml相应文件的位置。
  
  * MyBatis Log Plugin
  * 可直接将Mybatis执行的sql脚本显示出来，无需处理，可以直接复制出来执行的


###java为什么使用TypeReference
    资料地址 ：https://www.cnblogs.com/kaituorensheng/p/9804097.html#_label0
    
    在使用fastJson时,对于泛型的反序列化很多场景下都会使用到TypeReference
    void testTypeReference() {
            List<Integer> list = new ArrayList<>();
            list.add(1);
            list.add(9);
            list.add(4);
            list.add(8);
            JSONObject jsonObj = new JSONObject();
            jsonObj.put("a", list);
            System.out.println(jsonObj);
            List<String> list2 = jsonObj.getObject("a", new TypeReference<List<Integer>>(){});
            System.out.println(list2);
        }
        使用TypeReference可以明确的指定反序列化的类型，具体实现逻辑参考TypeReference的构造函数
          protected TypeReference(){
            Type superClass = getClass().getGenericSuperclass();
            Type type = ((ParameterizedType) superClass).getActualTypeArguments()[0];
            Type cachedType = classTypeCache.get(type);
            if (cachedType == null) {
                classTypeCache.putIfAbsent(type, type);
                cachedType = classTypeCache.get(type);
            }
            this.type = cachedType;
        }
        解说：其中核心的方法是：getActualTypeArguments，它可以得到父类的反省类型
    ParameterizedType是一个记录类型泛型的接口, 继承自Type,一共三方法:
    
    Type[] getActualTypeArguments(); //返回泛型类型数组
    Type getRawType(); //返回原始类型Type
    Type getOwnerType(); //返回 Type 对象，表示此类型是其成员之一的类型。
    例如 Map<String,String> 对应的ParameterizedType三个方法分别取值如下:

    [class java.lang.String, class java.lang.String]
    interface java.util.Map
    null


### stringbuffer
###  代码优化
      //不要在循环体中实例化，做复杂的运算，加同步锁,加Try/Catch语句
      //1、使用条件操作符替代"if (cond) return; else return;" 结构 
      
     // 条件操作符更加的简捷 
      //例子： 
      public class if {
          public int method(boolean isdone) {
              if (isdone) {
                  return 0;
              } else {
                  return 10;
              }
          }
      }
      //更正： 
      public class if {
          public int method(boolean isdone) {
              return (isdone ? 0 : 10);
          }
      }
      
      //2、使用条件操作符代替"if (cond) a = b; else a = c;" 结构 
      //例子： 
      public class ifas {
          void method(boolean istrue) {
              if (istrue) {
                  _value = 0;
              } else {
                  _value = 1;
              }
          }
          private int _value = 0;
      }
      //更正： 
      public class ifas {
          void method(boolean istrue) {
              _value = (istrue ? 0 : 1);       // compact expression.
          }
          private int _value = 0;
      }

  ##mybatis中like查询防止注入
  and jysnd.goods_name like concat(concat('%',#{goodsName}),'%')

  ###刷新页面四种方式
  //window.location.reload()
  //window.history.go(0)
  //document.execCommand("Refresh")
  $(".search").click();
  
  ###request方法
  * request.getContextPath()获取当前项目根地址 ，
  * request.getSchema()可以返回当前页面使用的协议，http 或是 https;
  * request.getServerName()可以返回当前页面所在的服务器的名字;
  * request.getServerPort()可以返回当前页面所在的服务器使用的端口,就是80;
  * request.getContextPath()可以返回当前页面所在的应用的名字;
 ### ---
* lists.newarraylist()：
* List<String> list = new ArrayList<String>(); 
* new arraylist() ：
* List<String> list = Lists.newArrayList();
* Lists和Maps是两个工具类, Lists.newArrayList()其实和new ArrayList()几乎一模一样, 唯一它帮你做的(其实是javac帮你做的), 就是自动推导(不是"倒")尖括号里的数据类型. 

 ### swagger2 生成接口文档技术


 ### HashSet contains()方法实现机制
          // 判断提交的skuId数据是否有重复
          if (CollectionUtils.isNotEmpty(updateReqDTO.getUpdateInfoList())) {
              Set<String> skuIdSet = new HashSet<>(16);
              for (OutGoodsUpdateInfoReqDTO infoReqDTO : updateReqDTO.getUpdateInfoList()) {
                  if (skuIdSet.contains(infoReqDTO.getSkuId())) {
                      return ServiceResult.buildFail(String.format("修改失败:有相同的skuId:%s!", infoReqDTO.getSkuId()));
                  } else {
                      skuIdSet.add(infoReqDTO.getSkuId());
                  }
              }
          }

###  Spring: 
      @Transactional
      在Spring的事务管理中，我们可以使用@Transactional这一annotation来对事务进行声明式的设定。
      
      @EnableAspectJAutoProxy(exposeProxy = true)表示开启AOP代理自动配置，如果配@EnableAspectJAutoProxy表示使用cglib进行代理对象的生成；
      设置@EnableAspectJAutoProxy(exposeProxy=true)表示通过aop框架暴露该代理对象，aopContext能够访问.
      
###  java的@Async异步方法
 
###  复制对象属性
     CopyUtil.copyObject()

### hashmap的源代码

### Xstream是一个功能比较强大的xml和java对象互转的工具包。
 
### 在新标签页中打开的方法:给链接添加target属性即可
    <a href="http://www.baidu.com"  target="_blank">链接</a>
### String转Json
     public Result sortRecommend(String req) {
        List<RecommendReq> reqs = JSONArray.parseArray(req, RecommendReq.class);
        return recommendService.sortRecommend(reqs);
     }
     
### 查询本机IP地址
    ipconfig /all     
### 代码规范
   1. 工程代码结构约定
  biz 数据(后端)业务模块
   数据业务,实现并暴露自己的业务接口
  service 服务模块
   三方服务接口 (ex 顺风,工猫)
  common 公共模块
   工具类,常量类,枚举类
  web (前端)模块
   前端业务 页面数据对象(VO),对页面的接口(Controller)
   不能把数据库对象用作VO
   *输出用统一用Result封装
  
  2. 公用模块
  实体类 
  表实体类名必须和表明一致 (如tbl_su_user实体类名为SuUser)
  *除了lombok不能引入其他jar
  *表实体类字段必须和表完全一致,不能添加自己的字段
  *更新字段值时只更新需要更新的字段 避免数据库查出来的对象更新完再更新回去!
  *工具类 尽量少引入jar
  
  3. 接口约定
  * 返回结果统一封装 公用的封装类Result
  
  * 对工程外的接口必须catch异常且记录log 不要e.printStackTrace()
  
  * 重要的接口必须要有重试机制(防止网络抖动,服务切换,建议重试三次,每次间隔3s) 可捕获IOException处理
  
  
  必须统一前缀 tbl_
  *索引 避免全表扫描
  
  锁. 避免锁全表 尽量根据主键更新和删除. 锁的原理. 行锁,表锁
  
  事务需要慎用,事务需要尽可能覆盖小,时间短
  建议自己拿不准的sql找人审核
  时效极高的走主库
  
  正式环境分批发布,每批暂停,间隔一分钟再发第二批
  git不要提交.idea, .iml跟代码无关的文件上去
  
  其他: 所有涉及money的字段值变动必须要有log,可追溯
  
  消息队列的使用
  消息分组.
