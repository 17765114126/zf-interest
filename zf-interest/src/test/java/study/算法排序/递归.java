package study.算法排序;

import org.junit.Test;

import java.util.Arrays;

/**
 * @ClassName 递归
 * @Author zhaofu
 * @Date 2021/1/19
 * @Version V1.0
 * <p>
 * 递归在程序语言中简单的理解是：方法自己调用自己
 * <p>
 * 递归其实和循环是非常像的，循环都可以改写成递归，递归未必能改写成循环，这是一个充分不必要的条件。
 * <p>
 * 那么，有了循环，为什么还要用递归呢？？在某些情况下(费波纳切数列，汉诺塔)，使用递归会比循环简单很多很多
 * <p>
 * 话说多了也无益，让我们来感受一下递归吧。
 * <p>
 * 我们初学编程的时候肯定会做过类似的练习：
 * <p>
 * 1+2+3+4+....+100(n)求和
 * <p>
 * 给出一个数组，求该数组内部的最大值
 * <p>
 * 我们要记住的是，想要用递归必须知道两个条件：
 * <p>
 * 递归出口(终止递归的条件)
 * <p>
 * 递归表达式(规律)
 * <p>
 * 技巧：在递归中常常是将问题切割成两个部分(1和整体的思想)，这能够让我们快速找到递归表达式(规律)
 **/
public class 递归 {

    public static void main(String[] args) {
        /**如果我们使用for循环来进行求和1+2+3+4+....+100，那是很简单的：*/
        int sum = 0;
        for (int i = 1; i <= 100; i++) {

            sum = sum + i;

        }
        System.out.println("sum：" + sum);
    }

    /**
     *
     * 前面我说了，for循环都可以使用递归来进行改写，而使用递归必须要知道两个条件：1、递归出口，2、递归表达式(规律)
     *
     * 首先，我们来找出它的规律：1+2+3+...+n，这是一个求和的运算，那么我们可以假设X=1+2+3+...+n，可以将1+2+3+...+(n-1)看成是一个整体。
     * 而这个整体做的事又和我们的初始目的(求和)相同。以我们的高中数学知识我们又可以将上面的式子看成X=sum(n-1)+n
     *
     * 好了，我们找到我们的递归表达式(规律)，它就是sum(n-1)+n,那递归出口呢，这个题目的递归出口就有很多了，我列举一下：
     *
     * 如果n=1时，那么就返回1
     *
     * 如果n=2时，那么就返回3(1+2)
     *
     * 如果n=3时，那么就返回6(1+2+3)
     *
     * 当然了，我肯定是使用一个最简单的递归出口了：if(n=1) return 1
     *
     * 递归表达式和递归出口我们都找到了，下面就代码演示：
     *
     * 递归出口为1：
     *
     * */
    /**
     * 递归出口为1：
     */
    @Test
    public void Test() {
        System.out.println("sum1：" + sum1(100));
        System.out.println("sum1-2：" + sum12(1));

    }

    /**
     * @param n 要加到的数字，比如题目的100
     * @return
     */
    public static int sum1(int n) {

        if (n == 1) {
            return 1;
        } else {
            return sum1(n - 1) + n;
        }
    }

    public static int sum12(int n) {
        if (n == 100) {
            return 1;
        } else {
            return sum12(n + 1) + n + 1;
        }
    }

    /**
     * 递归出口为4：
     */
    @Test
    public void Test2() {
        System.out.println("sum2：" + sum2(100));
    }

    /**
     * @param n 要加到的数字，比如题目的100
     * @return
     */
    public static int sum2(int n) {

        //如果递归出口为4，(1+2+3+4)
        if (n == 4) {
            return 10;
        } else {
            return sum2(n - 1) + n;
        }
    }
    /**结果都是一样的。*/

    /**
     * 数组内部的最大值
     * 如果使用的是循环，那么我们通常这样实现：
     */

    @Test
    public void Test3() {
        int[] arrays = {2, 3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2};

        //将数组的第一个假设是最大值
        int max = arrays[0];

        for (int i = 1; i < arrays.length; i++) {

            if (arrays[i] > max) {
                max = arrays[i];
            }
        }

        System.out.println("max：" + max);
    }

    /**
     * 那如果我们用递归的话，那怎么用弄呢？首先还是先要找到递归表达式(规律)和递归出口
     * <p>
     * 我们又可以运用1和整体的思想来找到规律
     * <p>
     * 将数组第一个数->2与数组后面的数->{3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2}进行切割，
     * 将数组后面的数看成是一个整体X={3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2}，
     * 那么我们就可以看成是第一个数和一个整体进行比较if(2>X) return 2  else(2<X) return X
     * <p>
     * 而我们要做的就是找出这个整体的最大值与2进行比较。找出整体的最大值又是和我们的初始目的(找出最大值)是一样的
     * <p>
     * 也就可以写成if( 2>findMax() )return 2 else return findMax()
     * <p>
     * 递归出口，如果数组只有1个元素时，那么这个数组最大值就是它了。
     * <p>
     * 使用到数组的时候，我们通常为数组设定左边界和右边界，这样比较好地进行切割
     * <p>
     * L表示左边界，往往表示的是数组第一个元素，也就会赋值为0(角标为0是数组的第一个元素)
     * <p>
     * R表示右边界，往往表示的是数组的长度，也就会赋值为arrays.length-1（长度-1在角标中才是代表最后一个元素)
     * <p>
     * 那么可以看看我们递归的写法了：
     */

    @Test
    public void Test4() {
        int[] arrays = {2, 3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 1};
        System.out.println("findMax：" + findMax(arrays, 0, arrays.length - 1));
    }

    /**
     * 递归，找出数组最大的值
     *
     * @param arrays 数组
     * @param L      左边界，第一个数
     * @param R      右边界，数组的长度
     * @return
     */

    public static int findMax(int[] arrays, int L, int R) {

        //如果该数组只有一个数，那么最大的就是该数组第一个值了
        if (L == R) {
            return arrays[L];
        } else {
            int a = arrays[L];
            int b = findMax(arrays, L + 1, R);//找出整体的最大值
            if (a > b) {
                return a;
            } else {
                return b;
            }
        }
    }

    /**
     * 冒泡排序递归写法
     * 在冒泡排序章节中给出了C语言的递归实现冒泡排序，那么现在我们已经使用递归的基本思路了，我们使用Java来重写一下看看：
     * <p>
     * 冒泡排序：俩俩交换，在第一趟排序中能够将最大值排到最后面，外层循环控制排序趟数，内层循环控制比较次数
     * <p>
     * 以递归的思想来进行改造：
     * <p>
     * 当第一趟排序后，我们可以将数组最后一位(R)和数组前面的数(L,R-1)进行切割，数组前面的数(L,R-1)看成是一个整体，
     * 这个整体又是和我们的初始目的(找出最大值，与当前趟数的末尾处交换)是一样的
     * <p>
     * 递归出口：当只有一个元素时，即不用比较了：L==R
     */

    @Test
    public void Test5() {
        int[] arrays = {2, 3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 1};
        bubbleSort(arrays, 0, arrays.length - 1);
        System.out.println("arrays：" + Arrays.toString(arrays));
    }

    public static void bubbleSort(int[] arrays, int L, int R) {
        int temp;
        //如果只有一个元素了，那什么都不用干
        if (L == R) ;

        else {
            for (int i = L; i < R; i++) {
                if (arrays[i] > arrays[i + 1]) {
                    temp = arrays[i];
                    arrays[i] = arrays[i + 1];
                    arrays[i + 1] = temp;
                }
            }
            //第一趟排序后已经将最大值放到数组最后面了
            //接下来是排序"整体"的数据了
            bubbleSort(arrays, L, R - 1);
        }
    }

    /**
     * 斐波那契数列
     * 接触过C语言的同学很可能就知道什么是费波纳切数列了，因为往往做练习题的时候它就会出现，它也是递归的典型应用。
     * <p>
     * 菲波那切数列长这个样子：{1 1 2 3 5 8 13 21 34 55..... n }
     * <p>
     * 数学好的同学可能很容易就找到规律了：前两项之和等于第三项
     * <p>
     * 例如：
     * <p>
     * 1 + 1 = 2
     * 2 + 3 = 5
     * 13 + 21 = 34
     * 如果让我们求出第n项是多少，那么我们就可以很简单写出对应的递归表达式了：Z = (n-2) + (n-1)
     * <p>
     * 递归出口在本题目是需要有两个的，因为它是前两项加起来才得出第三项的值
     * <p>
     * 同样地，那么我们的递归出口可以写成这样：if(n==1) retrun 1 if(n==2) return 2
     * <p>
     * 下面就来看一下完整的代码吧：
     */

    @Test
    public void Test6() {
        int[] arrays = {1, 1, 2, 3, 5, 8, 13, 21};
        bubbleSort(arrays, 0, arrays.length - 1);
        int fibonacci = fibonacci(8);
        System.out.println("fibonacci：" + fibonacci);
    }

    public static int fibonacci(int n) {
        if (n == 1) {
            return 1;
        } else if (n == 2) {
            return 1;
        } else {
            return (fibonacci(n - 1) + fibonacci(n - 2));
        }
    }

    /**
     * 汉诺塔算法
     * 玩汉诺塔的规则很简单：
     * <p>
     * 有三根柱子，原始装满大小不一的盘子的柱子我们称为A，还有两根空的柱子，我们分别称为B和C(任选)
     * <p>
     * 最终的目的就是将A柱子的盘子全部移到C柱子中
     * <p>
     * 移动的时候有个规则：一次只能移动一个盘子，小的盘子不能在大的盘子上面(反过来：大的盘子不能在小的盘子上面)
     * <p>
     * 我们下面就来玩一下：
     * <p>
     * 只有一个盘子：
     * 将A柱子的盘子直接移动到C柱子中
     * 完成游戏
     * <p>
     * 只有两个盘子：
     * 将A柱子上的小盘子移动到B柱子中
     * 将A柱子上的大盘子移动到C柱子中
     * 最后将在B柱子的小盘子移动到C柱子大盘子中
     * 完成游戏
     * <p>
     * 只有三个盘子：
     * 将A柱子小的盘子移动到C柱子中
     * 将A柱子上的中盘子移动到B柱子中
     * 将C柱子小盘子移动到B柱子中盘子中
     * 将A柱子的大盘子移动到C柱子中
     * 将B柱子的小盘子移动到A柱子中
     * 将B柱子的中盘子移动到C柱子中
     * 最后将A柱子的小盘子移动到C柱子中
     * 完成游戏
     * <p>
     * …………………..
     * <p>
     * 从前三次玩法中我们就可以发现的规律：
     * 想要将最大的盘子移动到C柱子，就必须将其余的盘子移到B柱子处(借助B柱子将最大盘子移动到C柱子中[除了最大盘子，将所有盘子移动到B柱子中])[递归表达式]
     * 当C柱子有了最大盘子时，所有的盘子在B柱子。现在的目的就是借助A柱子将B柱子的盘子都放到C柱子中(和上面是一样的，已经发生递归了)
     * 当只有一个盘子时，就可以直接移动到C柱子了(递归出口)
     * A柱子称之为起始柱子，B柱子称之为中转柱子，C柱子称之为目标柱子
     * <p>
     * 从上面的描述我们可以发现，起始柱子、中转柱子它们的角色是会变的（A柱子开始是起始柱子，第二轮后就变成了中转柱子了。
     * B柱子开始是目标柱子，第二轮后就变成了起始柱子。
     * 总之，起始柱子、中转柱子的角色是不停切换的)
     * <p>
     * 简单来说就分成三步：
     * 把 n-1 号盘子移动到中转柱子
     * 把最大盘子从起点移到目标柱子
     * 把中转柱子的n-1号盘子也移到目标柱子
     * <p>
     * 那么就可以写代码测试一下了(回看上面玩的过程)：
     */
    @Test
    public void Test7() {
        hanoi(5, 'A', 'B', 'C');
    }

    /**
     * 汉诺塔
     *
     * @param n        n个盘子
     * @param start    起始柱子
     * @param transfer 中转柱子
     * @param target   目标柱子
     */
    public static void hanoi(int n, char start, char transfer, char target) {
        //只有一个盘子，直接搬到目标柱子
        if (n == 1) {
            System.out.println(start + "---->" + target);
        } else {
            //起始柱子借助目标柱子将盘子都移动到中转柱子中(除了最大的盘子)
            hanoi(n - 1, start, target, transfer);
            System.out.println(start + "---->" + target);
            //中转柱子借助起始柱子将盘子都移动到目标柱子中
            hanoi(n - 1, transfer, start, target);
        }
    }
    /**
     * 总结
     * 递归的确是一个比较难理解的东西，好几次都把我绕进去了….
     *
     * 要使用递归首先要知道两件事：
     * 递归出口(终止递归的条件)
     * 递归表达式(规律)
     *
     * 在递归中常常用”整体“的思想，在汉诺塔例子中也不例外：
     * 将最大盘的盘子看成1，上面的盘子看成一个整体。
     * 那么我们在演算的时候就很清晰了：将”整体“搬到B柱子，将最大的盘子搬到C柱子，最后将B柱子的盘子搬到C柱子中
     *
     * 因为我们人脑无法演算那么多的步骤，递归是用计算机来干的，只要我们找到了递归表达式和递归出口就要相信计算机能帮我们搞定。
     *
     * 在编程语言中，递归的本质是方法自己调用自己，只是参数不一样罢了。
     * */
}
